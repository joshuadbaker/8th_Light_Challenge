Tic Tac Toe Challenge Submission, 8th Light
by Joshua Baker, joshuadbaker10@gmail.com

I enjoyed this challenge.  I liked receiving a memo with feature requests that needed to be added and the request for the app to be refactored into a more flexible application.  I have taken significant time to complete the challenge and learned a great deal. The challenge also taught me a lot about knowledge I have acquired over the past 6 months but haven’t had many opportunities to apply in a real world situation.  I really enjoyed breaking down the initial app into separate objects and then linking them up.  I also enjoyed exploring what to break out and how to break out elements.  I know the separation of concerns is an important concept, but to actually apply the concept was exciting.  I’m sure there is much more I can learn about it.  

Next, I tried to apply the idea of MVP to this challenge.  Initially, instead of breaking everything out into separate files, I tried to execute most of the requests in the single page app first, including making the game unbeatable though not in the most efficient way as I would learn later in the challenge.  After getting the app to work, I tried to follow a basic git workflow and create new branches as I changed the structure of the app to be more sophisticated and I separated the command line user experience from the code of the game itself.  

Next, perhaps the most difficult but engaging part of the challenge was tackling the feature of the computer being unbeatable.  Initially(I have left this code as commented out in the computer file), I ended up building out a bunch of individual conditions to meet the different situations or states that might arise as a game unfolds.  As I worked through this though, I had the sense there must be a better way, not to mention, I was unsure as to whether all of my conditions were even necessary.  After breaking the app out into separate objects, I did some research and discovered the minimax algorithm.  I immediately decided to try to apply the algorithm to my own code as a learning experience given that I am only beginning to learn about widely basic algorithms.  

While I have not been able to get the algorithm to function correctly, I think I am close.  I have learned a great deal about how code and computers work and about how this algorithm works.  Before even looking at an algorithm I diagramed out tic tac toe as a tree of choices and how each turn becomes not only a state, but a level of progression in the game that leads to a conclusion.  Having worked this out before looking at any algorithm helped me to break down what was happening inside the algorithm in terms of creating a recursive method that evaluates moves on a hypothetical game board.  As the method recurses through each state, it evaluates the move against a simple value system that adds, subtracts, or results in zero value if neither side wins.  Each move then is evaluated as either a minimum or maximum value to be used as the actual best move.  Adding depth to algorithm accounts for the turns taken and allows for the method to adjust values based on how many moves exist until a game is concluded.  This way the method plays out the best moves to prevent losing as opposed to immediately accounting for a lost game.     

Even though I am still trying to get the algorithm to work correctly, I am beginning to appreciate how abstracted human problem solving is versus how a computer must be instructed to solve the same problem in explicit steps.  Humans make connections and think at least 1-2 moves ahead intuitively without the necessity of creating explicit structures like state and depth to solve a problem.  I am beginning to see how much I need to adapt my approach to using logic to how computers use logic to create efficient clean code.  The reason I wanted to try to tackle to algorithm even though I have never used it before was to begin to expose myself to a new level of coding and structure for how a computer solves problems though recursive methods.

One final issue that led me to submitting the code now is that while troubleshooting the algorithm I ran into an odd bug while using the Pry gem.  Everything was working as it should when I’d call a binding.pry to analyze my code when suddenly pry started acting strangely, getting stuck inside the the minimax algorithm.  I spent time researching the issue online but found little help about my specific issue.  I found other issues about bugs in pry, but nothing specific to my issue.  Given time is already running out for submitting the challenge and given how much I have completed of the challenge, I wanted to submit it anyway with some explanation for its current state.        